<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Flute Spark â€” Random Eb Major Line</title>

  <!-- VexFlow (notation) -->
  <script src="https://unpkg.com/vexflow@4.2.3/build/cjs/vexflow.js"></script>

  <!-- SoundFont playback (sampled â€œMIDI-likeâ€ flute) -->
  <script src="https://unpkg.com/soundfont-player@0.15.7/dist/soundfont-player.js"></script>

  <style>
    :root{
      --bg1:#fff5f8; --bg2:#ffe3ee; --card:#ffffffcc;
      --ink:#2a1b22; --muted:#6a4a58;
      --accent:#ff3b7a; --accent2:#ff7aa8;
      --shadow: 0 18px 50px rgba(30,10,20,.12);
      --radius: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #fff, transparent 55%),
        radial-gradient(1000px 700px at 50% 95%, #ffd3e4, transparent 60%),
        linear-gradient(180deg, var(--bg1), #fff);
      overflow-x:hidden;
    }
    .hearts{ position:fixed; inset:0; pointer-events:none; z-index:0; opacity:.55; }
    .heart{
      position:absolute; width:16px; height:16px; transform: rotate(45deg);
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      border-radius: 3px;
      filter: drop-shadow(0 6px 8px rgba(255,59,122,.18));
      animation: floatUp linear infinite;
    }
    .heart::before,.heart::after{
      content:""; position:absolute; width:16px; height:16px; background:inherit; border-radius:50%;
    }
    .heart::before{ left:-8px; top:0; } .heart::after{ left:0; top:-8px; }
    @keyframes floatUp{ from{transform:translateY(120vh) rotate(45deg);opacity:0} 15%{opacity:1} to{transform:translateY(-20vh) rotate(45deg);opacity:0} }

    .wrap{ position:relative; z-index:1; max-width: 980px; margin:0 auto; padding:44px 18px 54px; }
    header{ margin-bottom:18px; }
    h1{ margin:0 0 8px 0; font-size: clamp(26px, 4vw, 40px); letter-spacing:-0.02em; line-height:1.05; }
    .subtitle{ margin:0; color:var(--muted); font-size:15px; line-height:1.45; max-width:72ch; }

    .card{
      background: var(--card); backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{
      display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between;
      gap:12px; padding:14px 16px;
      border-bottom:1px solid rgba(50,20,35,.08);
    }
    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    button{
      appearance:none; border:none; padding:10px 14px; border-radius:14px; cursor:pointer;
      font-weight:650; font-size:14px; letter-spacing:.01em; color:white;
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      box-shadow: 0 10px 22px rgba(255,59,122,.25);
    }
    button.secondary{
      color: var(--ink);
      background: linear-gradient(180deg, #ffffff, #ffe9f2);
      border:1px solid rgba(255,59,122,.25);
      box-shadow: 0 10px 22px rgba(30,10,20,.08);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .pill{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; color:var(--muted); font-size:13px; }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px; border-radius:999px;
      background: rgba(255,255,255,.75);
      border:1px solid rgba(50,20,35,.08);
    }
    .dot{ width:10px; height:10px; border-radius:999px; background:var(--accent); box-shadow:0 0 0 4px rgba(255,59,122,.15); }

    .stage{ padding:16px; }
    #notation{
      width:100%;
      overflow-x:auto;
      padding:10px;
      border-radius:18px;
      background: rgba(255,255,255,.65);
      border:1px solid rgba(50,20,35,.08);
    }
    .footer{
      margin-top:14px; display:flex; flex-wrap:wrap; gap:10px;
      align-items:center; justify-content:space-between;
      color:var(--muted); font-size:13px; padding:0 6px;
    }
    .small{ opacity:.9; line-height:1.4; }
  </style>
</head>

<body>
  <div class="hearts" id="hearts"></div>

  <div class="wrap">
    <header>
      <h1>Valentine Flute Spark ðŸ’˜</h1>
      <p class="subtitle">
        Fast one-line flute passage in <b>Eâ™­ major</b> with strict rules:
        <b>no repeated adjacent notes</b>, leaps â‰¤ <b>perfect fifth</b>,
        16ths only as <b>2</b> in a row, <b>4</b> in a row, or <b>16th + dotted 8th</b>,
        and <b>no bar ends on a 16th</b>.
      </p>
    </header>

    <div class="card">
      <div class="topbar">
        <div class="controls">
          <button id="btnGen">Generate âœ¨</button>
          <button id="btnPlay" class="secondary">Play (Flute) â–¶ï¸Ž</button>
          <button id="btnStop" class="secondary" disabled>Stop â– </button>
        </div>
        <div class="pill">
          <span class="badge"><span class="dot"></span><span id="meta">Eâ™­ major â€¢ 4/4 â€¢ â™©=156 â€¢ 4 bars</span></span>
        </div>
      </div>

      <div class="stage">
        <div id="notation"></div>
        <div class="footer">
          <div class="small">If audio doesnâ€™t start, click <b>Play</b> once more (browser gesture rule).</div>
          <div class="small">VexFlow + SoundFont flute</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ----------------------------
   Floating hearts
----------------------------- */
(function makeHearts(){
  const wrap = document.getElementById("hearts");
  const count = 26;
  for (let i=0;i<count;i++){
    const h = document.createElement("div");
    h.className = "heart";
    const left = Math.random()*100;
    const size = 10 + Math.random()*14;
    const dur  = 8 + Math.random()*10;
    const delay = -Math.random()*dur;
    h.style.left = left + "vw";
    h.style.width = size + "px";
    h.style.height = size + "px";
    h.style.animationDuration = dur + "s";
    h.style.animationDelay = delay + "s";
    h.style.opacity = (0.25 + Math.random()*0.6).toFixed(2);
    wrap.appendChild(h);
  }
})();

/* ----------------------------
   Core settings
----------------------------- */
const TEMPO = 156;
const BARS = 4;
const TIME_SIG = "4/4";

const SCALE_VEX = ["eb","f","g","ab","bb","c","d"]; // Eb major
const MIDI_MIN = 60; // C4
const MIDI_MAX = 84; // C6
const MAX_LEAP = 7;  // semitones (perfect fifth)

// Utility
function randInt(n){ return Math.floor(Math.random()*n); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for (let i=0;i<items.length;i++){ r -= weights[i]; if (r <= 0) return items[i]; }
  return items[items.length-1];
}
function vexKey(pc, oct){ return `${pc}/${oct}`; }
function vexToToneName(vk){
  const [pc, oct] = vk.split("/");
  const letter = pc[0].toUpperCase();
  const accidental = pc.length > 1 ? "b" : "";
  return `${letter}${accidental}${oct}`;
}
// MIDI from note like "Eb5"
function noteToMidi(note){
  const m = note.match(/^([A-G])([b#]?)(\d)$/);
  if (!m) return 72;
  const letter = m[1], acc = m[2], oct = parseInt(m[3],10);
  const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[letter];
  const a = acc === "b" ? -1 : (acc === "#" ? 1 : 0);
  return (oct + 1) * 12 + base + a;
}

/* ============================================================
   1) RHYTHM: PRECOMPUTE valid 4/4 rhythm sequences for ONE BAR
      No â€œtry until it worksâ€. We ONLY sample from valid sequences.
   ============================================================ */

/*
Each note token is:
{ beats: number, dur: "16"|"8"|"q"|"h", dots: 0|1 }

Rules:
- 16ths only appear as:
  (a) 16+16
  (b) 16+16+16+16
  (c) 16 + dotted 8th
- no bar ends on a 16th token
*/

const TOK = {
  s16: {beats:0.25, dur:"16", dots:0},
  e8:  {beats:0.50, dur:"8",  dots:0},
  e8d: {beats:0.75, dur:"8",  dots:1},
  q:   {beats:1.00, dur:"q",  dots:0},
  qd:  {beats:1.50, dur:"q",  dots:1},
  h:   {beats:2.00, dur:"h",  dots:0},
};

const CHUNKS = [
  [TOK.e8],
  [TOK.e8d],
  [TOK.q],
  [TOK.qd],
  [TOK.h],
  // 16th patterns
  [TOK.s16, TOK.s16],                          // two 16ths
  [TOK.s16, TOK.s16, TOK.s16, TOK.s16],        // four 16ths
  [TOK.s16, TOK.e8d],                          // 16th + dotted 8th
];

function sumBeats(seq){ return seq.reduce((s,t)=>s+t.beats,0); }

function isValidBar(seq){
  const total = sumBeats(seq);
  if (Math.abs(total - 4.0) > 1e-9) return false;
  if (seq.length && seq[seq.length-1].dur === "16") return false; // no ending on 16th

  // Enforce: 16ths only in allowed patterns, i.e. no single 16 and no 16 adjacent to non-16 except:
  // - within a run of 2 or 4 16ths
  // - or the special pattern 16 + dotted 8th
  for (let i=0;i<seq.length;i++){
    if (seq[i].dur !== "16") continue;

    // If it's a 16th, check pattern context
    const next = seq[i+1];
    if (!next) return false;
    if (next.dur === "16") {
      // Must be part of run length 2 or 4
      let run = 1;
      let j = i+1;
      while (j < seq.length && seq[j].dur === "16"){ run++; j++; }
      if (!(run === 2 || run === 4)) return false;
      i = j-1; // skip run
    } else {
      // Must be 16 + dotted 8th
      if (!(next.dur === "8" && next.dots === 1)) return false;
      i += 1; // skip next
    }
  }
  return true;
}

let VALID_BAR_RHYTHMS = [];

function buildValidBarRhythms(){
  const results = [];
  const target = 4.0;

  function dfs(current, beats){
    if (beats > target + 1e-9) return;
    if (Math.abs(beats - target) < 1e-9){
      if (isValidBar(current)) results.push(current.slice());
      return;
    }
    for (const chunk of CHUNKS){
      const b = sumBeats(chunk);
      if (beats + b > target + 1e-9) continue;

      // quick pruning: avoid ever leaving exactly 0.25 beats remaining (would force a forbidden single 16)
      const remainingAfter = target - (beats + b);
      if (Math.abs(remainingAfter - 0.25) < 1e-9) continue;

      current.push(...chunk);
      dfs(current, beats + b);
      current.splice(current.length - chunk.length, chunk.length);
    }
  }

  dfs([], 0);
  // Keep a healthy variety: filter out bars that are too slow (e.g. two halves)
  VALID_BAR_RHYTHMS = results.filter(seq => {
    const count16 = seq.filter(t=>t.dur==="16").length;
    const count8  = seq.filter(t=>t.dur==="8" && t.dots===0).length;
    return (count16 + count8) >= 2; // at least some motion
  });
}

buildValidBarRhythms();

/* ============================================================
   2) MELODY: generate pitches with guaranteed constraints
      - no adjacent repeats
      - leap <= fifth (7 semitones)
      - diatonic Eb major
      No â€œinfinite whileâ€; bounded backtracking per bar.
   ============================================================ */

// Candidate melodic movement in scale steps (up to about a fifth diatonically)
const STEP_MOVES = [
  {d:-1,w:5.2},{d:+1,w:5.2},
  {d:-2,w:3.0},{d:+2,w:3.0},
  {d:-3,w:1.6},{d:+3,w:1.6},
  {d:-4,w:0.9},{d:+4,w:0.9},
];

function pickNextPitch(prevIdx, prevMidi){
  // Build a small list of valid candidates (no repeat, leap<=5th, in range)
  const candidates = [];
  for (const mv of STEP_MOVES){
    const idx = (prevIdx + mv.d + SCALE_VEX.length) % SCALE_VEX.length;
    const pc = SCALE_VEX[idx];

    // Try nearby octaves to keep it smooth
    const baseOct = prevMidi ? clamp(Math.floor(prevMidi/12)-1, 4, 6) : 5;
    const octs = [baseOct, baseOct+1, baseOct-1, baseOct+2, baseOct-2].map(o=>clamp(o,4,6));

    for (const oct of octs){
      const vk = vexKey(pc, oct);
      const tn = vexToToneName(vk);
      const midi = noteToMidi(tn);
      if (midi < MIDI_MIN || midi > MIDI_MAX) continue;
      if (prevMidi != null){
        const diff = Math.abs(midi - prevMidi);
        if (diff === 0) continue;
        if (diff > MAX_LEAP) continue;
      }
      candidates.push({idx, vexKey:vk, toneName:tn, midi, w: mv.w});
      break; // take closest octave that works for this step
    }
  }

  if (!candidates.length) return null;
  return weightedChoice(candidates, candidates.map(c=>c.w));
}

function makeMelodyForRhythm(barRhythm, startIdx, startMidi){
  // Bounded backtracking over notes in THIS bar
  const notes = [];
  let prevIdx = startIdx;
  let prevMidi = startMidi;

  // Depth-first with retry limits per position
  const maxRetriesPerNote = 18;
  const tried = new Array(barRhythm.length).fill(0);

  let i = 0;
  while (i < barRhythm.length){
    if (tried[i] > maxRetriesPerNote){
      // backtrack
      tried[i] = 0;
      if (i === 0) return null; // fail this bar
      notes.pop();
      i--;
      // restore prev to previous note (or start)
      if (i === 0){
        prevIdx = startIdx;
        prevMidi = startMidi;
      } else {
        prevIdx = notes[i-1].scaleIdx;
        prevMidi = notes[i-1].midi;
      }
      continue;
    }

    const pick = pickNextPitch(prevIdx, prevMidi);
    tried[i]++;

    if (!pick) continue;

    // Extra guard: if we just backtracked, avoid picking exactly the same pitch again too often
    if (notes.length && pick.midi === notes[notes.length-1].midi) continue;

    notes.push({
      scaleIdx: pick.idx,
      vexKey: pick.vexKey,
      toneName: pick.toneName,
      midi: pick.midi
    });

    prevIdx = pick.idx;
    prevMidi = pick.midi;
    i++;
  }

  return {notes, endIdx: prevIdx, endMidi: prevMidi};
}

/* ============================================================
   3) Generate full phrase instantly (4 bars)
      - rhythm: sample from precomputed valid bars
      - melody: bounded per-bar backtracking
   ============================================================ */

function generatePhrase(){
  const measures = [];

  // Starting point: choose a mid-range scale degree, mid octave
  let curIdx = randInt(SCALE_VEX.length);
  let curMidi = noteToMidi("Eb5");

  for (let m=0; m<BARS; m++){
    // pick a rhythm bar that wonâ€™t overcrowd too much
    const rhythm = weightedChoice(
      VALID_BAR_RHYTHMS,
      VALID_BAR_RHYTHMS.map(seq => {
        const n = seq.length;
        // prefer 6â€“12 notes per bar for readability
        if (n >= 6 && n <= 12) return 2.2;
        if (n <= 5) return 1.3;
        if (n <= 14) return 1.4;
        return 0.8;
      })
    );

    // generate melody for that rhythm (bounded; if fail, pick a new rhythm a few times)
    let melody = null;
    for (let tries=0; tries<10 && !melody; tries++){
      melody = makeMelodyForRhythm(rhythm, curIdx, curMidi);
      if (!melody){
        // swap rhythm and try again
        // (still bounded and fast because VALID_BAR_RHYTHMS is precomputed)
        // pick a different rhythm
        const idx = randInt(VALID_BAR_RHYTHMS.length);
        rhythm.length = 0;
        rhythm.push(...VALID_BAR_RHYTHMS[idx]);
      }
    }
    if (!melody){
      // ultra-rare fallback: simple eighth-note bar
      const fallbackRhythm = Array.from({length:8}, ()=>TOK.e8);
      melody = makeMelodyForRhythm(fallbackRhythm, curIdx, curMidi);
    }

    const bar = rhythm.map((rt, i) => ({
      vfDur: rt.dur,
      dots: rt.dots,
      beats: rt.beats,
      vexKey: melody.notes[i].vexKey,
      toneName: melody.notes[i].toneName,
      midi: melody.notes[i].midi
    }));

    // Ensure last token not 16th (already guaranteed by rhythm set)
    measures.push(bar);
    curIdx = melody.endIdx;
    curMidi = melody.endMidi;
  }

  // Nice ending: try to land final note on Eb (closest allowed within leap <= 5th and not repeated)
  const lastBar = measures[measures.length-1];
  if (lastBar && lastBar.length >= 2){
    const prev = lastBar[lastBar.length-2];
    const prevMidi = prev.midi;

    const ebCandidates = [4,5,6].map(o => ({
      toneName: `Eb${o}`,
      vexKey: `eb/${o}`,
      midi: noteToMidi(`Eb${o}`)
    })).filter(c =>
      c.midi >= MIDI_MIN && c.midi <= MIDI_MAX &&
      c.midi !== prevMidi &&
      Math.abs(c.midi - prevMidi) <= MAX_LEAP
    );

    if (ebCandidates.length){
      ebCandidates.sort((a,b)=>Math.abs(a.midi-prevMidi)-Math.abs(b.midi-prevMidi));
      const best = ebCandidates[0];
      lastBar[lastBar.length-1].toneName = best.toneName;
      lastBar[lastBar.length-1].vexKey = best.vexKey;
      lastBar[lastBar.length-1].midi = best.midi;
    }
  }

  return measures;
}

/* ============================================================
   4) Render (fix overlap by giving enough width)
      - Dotted notes handled via addDotToAll (NOT â€œ8dâ€ strings)
      - Even spacing via formatToStave
   ============================================================ */

let currentPhrase = null;

function computeRenderWidth(div, phrase){
  // increase width when there are many notes to avoid collisions
  const base = Math.max(740, div.clientWidth - 24);
  const maxNotesInBar = Math.max(...phrase.map(b => b.length));
  const extra = Math.max(0, maxNotesInBar - 10) * 26; // add width if >10 notes/bar
  const perBar = 260 * BARS;
  return Math.min(1600, Math.max(base, perBar + extra));
}

function renderPhrase(phrase){
  const div = document.getElementById("notation");
  div.innerHTML = "";

  const VF = Vex.Flow;
  const width = computeRenderWidth(div, phrase);
  const height = 220;

  const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
  renderer.resize(width, height);
  const context = renderer.getContext();

  const staveY = 64;
  const margin = 18;
  const totalStaveWidth = width - margin*2;
  const measureWidth = totalStaveWidth / BARS;

  const staves = [];
  for (let i=0;i<BARS;i++){
    const x = margin + i*measureWidth;
    const stave = new VF.Stave(x, staveY, measureWidth);
    if (i === 0){
      stave.addClef("treble").addTimeSignature(TIME_SIG).addKeySignature("Eb");
    }
    stave.setContext(context).draw();
    staves.push(stave);
  }

  for (let i=0;i<BARS;i++){
    const bar = phrase[i];

    const vexNotes = bar.map(n => {
      const sn = new VF.StaveNote({
        clef: "treble",
        keys: [n.vexKey],
        duration: n.vfDur
      });
      if (n.dots === 1) sn.addDotToAll();
      return sn;
    });

    // Beam only 8ths/16ths (VexFlow handles grouping)
    const beams = VF.Beam.generateBeams(vexNotes, { beam_rests:false });

    const voice = new VF.Voice({ num_beats: 4, beat_value: 4 }).setStrict(true);
    voice.addTickables(vexNotes);

    new VF.Formatter()
      .joinVoices([voice])
      .formatToStave([voice], staves[i], { padding: 10 });

    voice.draw(context, staves[i]);
    beams.forEach(b => b.setContext(context).draw());
  }
}

/* ============================================================
   5) Audio: SoundFont flute (reliable)
   ============================================================ */

let sfAudioCtx = null;
let sfInstrument = null;
let sfPlaying = [];
let sfStopTimer = null;

async function ensureFlute(){
  if (!sfAudioCtx){
    sfAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (sfAudioCtx.state === "suspended") await sfAudioCtx.resume();

  if (!sfInstrument){
    // MusyngKite is a popular high-quality SF set
    sfInstrument = await Soundfont.instrument(sfAudioCtx, "flute", { soundfont: "MusyngKite" });
  }
}

function stopPlayback(){
  try { sfPlaying.forEach(n => { try { n.stop(); } catch(e){} }); } catch(e){}
  sfPlaying = [];
  if (sfStopTimer){ clearTimeout(sfStopTimer); sfStopTimer = null; }

  document.getElementById("btnStop").disabled = true;
  document.getElementById("btnPlay").disabled = false;
}

function flattenToEvents(phrase){
  const events = [];
  let t = 0; // beats
  for (const bar of phrase){
    for (const n of bar){
      events.push({ timeBeats: t, note: n.toneName, beats: n.beats });
      t += n.beats;
    }
  }
  return events;
}

async function playPhrase(){
  await ensureFlute();
  stopPlayback();

  const events = flattenToEvents(currentPhrase);
  const beatSeconds = 60 / TEMPO;
  const startAt = sfAudioCtx.currentTime + 0.06;

  for (const e of events){
    const when = startAt + e.timeBeats * beatSeconds;
    const durSec = e.beats * beatSeconds;
    const node = sfInstrument.play(e.note, when, { duration: durSec, gain: 0.95 });
    sfPlaying.push(node);
  }

  document.getElementById("btnStop").disabled = false;
  document.getElementById("btnPlay").disabled = true;

  const totalSeconds = (BARS * 4) * beatSeconds;
  sfStopTimer = setTimeout(stopPlayback, (totalSeconds + 0.25) * 1000);
}

/* ============================================================
   UI wiring
   ============================================================ */

function generateAndRender(){
  stopPlayback();
  currentPhrase = generatePhrase();   // instant: only samples from valid bars + bounded melody backtracking
  renderPhrase(currentPhrase);
}

document.getElementById("btnGen").addEventListener("click", generateAndRender);
document.getElementById("btnPlay").addEventListener("click", () => playPhrase());
document.getElementById("btnStop").addEventListener("click", stopPlayback);

// First render
generateAndRender();
</script>
</body>
</html>
