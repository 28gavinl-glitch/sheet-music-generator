<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Flute Spark â€” Random Eb Major Line</title>

  <!-- VexFlow (notation) -->
  <script src="https://unpkg.com/vexflow@4.2.3/build/cjs/vexflow.js"></script>

  <!-- Tone.js (we only use it for note<->midi helpers + easy parsing) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <!-- SoundFont playback (sampled â€œMIDI-likeâ€ flute) -->
  <script src="https://unpkg.com/soundfont-player@0.15.7/dist/soundfont-player.js"></script>

  <style>
    :root{
      --bg1:#fff5f8;
      --bg2:#ffe3ee;
      --card:#ffffffcc;
      --ink:#2a1b22;
      --muted:#6a4a58;
      --accent:#ff3b7a;
      --accent2:#ff7aa8;
      --shadow: 0 18px 50px rgba(30, 10, 20, .12);
      --radius: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #fff, transparent 55%),
        radial-gradient(1000px 700px at 50% 95%, #ffd3e4, transparent 60%),
        linear-gradient(180deg, var(--bg1), #fff);
      overflow-x:hidden;
    }

    .hearts{ position:fixed; inset:0; pointer-events:none; z-index:0; opacity:.55; }
    .heart{
      position:absolute;
      width:16px; height:16px;
      transform: rotate(45deg);
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      border-radius: 3px;
      filter: drop-shadow(0 6px 8px rgba(255,59,122,.18));
      animation: floatUp linear infinite;
    }
    .heart::before, .heart::after{
      content:"";
      position:absolute;
      width:16px; height:16px;
      background: inherit;
      border-radius: 50%;
    }
    .heart::before{ left:-8px; top:0; }
    .heart::after{ left:0; top:-8px; }
    @keyframes floatUp{
      from{ transform: translateY(120vh) rotate(45deg); opacity:0; }
      15%{opacity:1;}
      to{ transform: translateY(-20vh) rotate(45deg); opacity:0; }
    }

    .wrap{
      position:relative; z-index:1;
      max-width: 980px;
      margin: 0 auto;
      padding: 44px 18px 54px;
    }

    header{ display:flex; align-items:flex-start; justify-content:space-between; gap:16px; margin-bottom:18px; }
    .title{ flex:1; }
    h1{ margin:0 0 8px 0; font-size: clamp(26px, 4vw, 40px); letter-spacing: -0.02em; line-height:1.05; }
    .subtitle{ margin:0; color:var(--muted); font-size: 15px; line-height:1.45; max-width: 70ch; }

    .card{
      background: var(--card);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .topbar{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(50,20,35,.08);
    }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }

    button{
      appearance:none;
      border:none;
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:650;
      font-size:14px;
      letter-spacing:.01em;
      color:white;
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      box-shadow: 0 10px 22px rgba(255,59,122,.25);
      transition: transform .08s ease, box-shadow .2s ease, opacity .2s ease;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button.secondary{
      color: var(--ink);
      background: linear-gradient(180deg, #ffffff, #ffe9f2);
      border: 1px solid rgba(255,59,122,.25);
      box-shadow: 0 10px 22px rgba(30,10,20,.08);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .pill{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; color: var(--muted); font-size: 13px; }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(50,20,35,.08);
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(255,59,122,.15);
    }

    .stage{ padding: 16px; }
    #notation{
      width:100%;
      overflow-x:auto;
      padding: 10px;
      border-radius: 18px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(50,20,35,.08);
    }

    .footer{
      margin-top: 14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      color: var(--muted);
      font-size: 13px;
      padding: 0 6px;
    }
    .small{ opacity:.9; line-height:1.4; }
  </style>
</head>

<body>
  <div class="hearts" id="hearts"></div>

  <div class="wrap">
    <header>
      <div class="title">
        <h1>Valentine Flute Spark ðŸ’˜</h1>
        <p class="subtitle">
          One-line, fast-tempo flute passage in <b>Eâ™­ major</b>.
          Rules: no repeated adjacent notes, leaps â‰¤ a <b>perfect fifth</b>,
          sixteenths only in <b>2</b> or <b>4</b> groups, or <b>16th + dotted 8th</b>, and no bar ends on a 16th.
        </p>
      </div>
    </header>

    <div class="card">
      <div class="topbar">
        <div class="controls">
          <button id="btnGen">Generate âœ¨</button>
          <button id="btnPlay" class="secondary">Play (Flute) â–¶ï¸Ž</button>
          <button id="btnStop" class="secondary" disabled>Stop â– </button>
        </div>

        <div class="pill">
          <span class="badge"><span class="dot"></span><span id="meta">Eâ™­ major â€¢ 4/4 â€¢ â™©=156 â€¢ 4 bars</span></span>
        </div>
      </div>

      <div class="stage">
        <div id="notation"></div>
        <div class="footer">
          <div class="small">If audio doesnâ€™t start, click <b>Play</b> once more (browser gesture rule).</div>
          <div class="small">VexFlow + SoundFont flute</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ----------------------------
   Floating hearts
----------------------------- */
(function makeHearts(){
  const wrap = document.getElementById("hearts");
  const count = 26;
  for (let i=0;i<count;i++){
    const h = document.createElement("div");
    h.className = "heart";
    const left = Math.random()*100;
    const size = 10 + Math.random()*14;
    const dur  = 8 + Math.random()*10;
    const delay = -Math.random()*dur;
    h.style.left = left + "vw";
    h.style.width = size + "px";
    h.style.height = size + "px";
    h.style.animationDuration = dur + "s";
    h.style.animationDelay = delay + "s";
    h.style.opacity = (0.25 + Math.random()*0.6).toFixed(2);
    wrap.appendChild(h);
  }
})();

/* ----------------------------
   Settings
----------------------------- */
const TEMPO = 156;
const BARS = 4;
const TIME_SIG = "4/4";

// Eb major diatonic pitch classes: Eb F G Ab Bb C D
const SCALE_VEX = ["eb", "f", "g", "ab", "bb", "c", "d"];

// Flute-ish range
const MIDI_MIN = 60; // C4
const MIDI_MAX = 84; // C6

// Max melodic leap: perfect fifth (7 semitones)
const MAX_SEMITONE_LEAP = 7;

// Helpers
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for (let i=0;i<items.length;i++){
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length-1];
}
function vexKey(pc, oct){ return `${pc}/${oct}`; }
function vexToToneName(vk){
  const [pc, oct] = vk.split("/");
  const letter = pc[0].toUpperCase();
  const accidental = pc.length > 1 ? "b" : "";
  return `${letter}${accidental}${oct}`;
}

/* ----------------------------
   Rhythm rules
   - Sixteenths allowed ONLY as:
     (a) 16 + 16
     (b) 16 + 16 + 16 + 16
     (c) 16 + dotted eighth
   - No bar ends on a 16th note
----------------------------- */

// Single-note rhythm atoms (non-16th)
const ATOMS = [
  { beats: 0.50, vf: "8",  toneDur: null },  // eighth
  { beats: 0.75, vf: "8d", toneDur: null },  // dotted eighth
  { beats: 1.00, vf: "q",  toneDur: null },  // quarter
  { beats: 1.50, vf: "qd", toneDur: null },  // dotted quarter
  { beats: 2.00, vf: "h",  toneDur: null }   // half
];

// Special 16th patterns (returned as arrays of atoms)
function rhythmChunksThatFit(remaining){
  const chunks = [];

  // Normal single-note chunks
  for (const a of ATOMS){
    if (a.beats <= remaining + 1e-9) chunks.push([a]);
  }

  // 16th patterns
  const chunk_2x16 = [
    { beats: 0.25, vf: "16", toneDur: null },
    { beats: 0.25, vf: "16", toneDur: null }
  ];
  const chunk_4x16 = [
    { beats: 0.25, vf: "16", toneDur: null },
    { beats: 0.25, vf: "16", toneDur: null },
    { beats: 0.25, vf: "16", toneDur: null },
    { beats: 0.25, vf: "16", toneDur: null }
  ];
  const chunk_16_plus_8d = [
    { beats: 0.25, vf: "16", toneDur: null },
    { beats: 0.75, vf: "8d", toneDur: null }
  ];

  const total = arr => arr.reduce((s,x)=>s+x.beats,0);

  // Only add 2x16 or 4x16 if they will NOT end the bar (so the bar doesn't end on 16th)
  // i.e., remaining must be strictly greater than chunk total.
  if (total(chunk_2x16) < remaining - 1e-9) chunks.push(chunk_2x16);
  if (total(chunk_4x16) < remaining - 1e-9) chunks.push(chunk_4x16);

  // 16 + dotted eighth is OK even if it ends the bar (last note is dotted 8th)
  if (total(chunk_16_plus_8d) <= remaining + 1e-9) chunks.push(chunk_16_plus_8d);

  // Also: if remaining is exactly 0.25, we cannot place a single 16th (forbidden),
  // so we rely on earlier choices to avoid ever reaching 0.25.
  // As an extra safeguard, if remaining is near 0.25, force a backtrack by disallowing choices earlier
  // (handled implicitly by not offering any chunks here).
  return chunks;
}

function pickRhythmChunk(remaining){
  const chunks = rhythmChunksThatFit(remaining);

  // If no chunks fit (should be rare), fall back to safest: use an eighth if possible.
  if (!chunks.length){
    if (remaining >= 0.5) return [{ beats:0.5, vf:"8", toneDur:null }];
    // Last resort: make it a quarter (won't happen in 4/4 with our options)
    return [{ beats:remaining, vf:"q", toneDur:null }];
  }

  // Weighting: favor faster feel, but not too many dotted quarters/halves.
  const weights = chunks.map(ch => {
    const t = ch.reduce((s,x)=>s+x.beats,0);
    const has16 = ch.some(x => x.vf === "16");
    const endsWith16 = ch[ch.length-1].vf === "16";
    const hasHalf = ch.some(x => x.vf === "h");
    const hasDotQuarter = ch.some(x => x.vf === "qd");

    let w = 1.0;

    if (has16) w *= 2.4;          // encourage tasteful 16ths
    if (t === 0.5) w *= 2.0;      // eighths are great for fast lines
    if (t === 1.0) w *= 1.4;
    if (t === 1.5) w *= 0.8;
    if (hasHalf) w *= 0.55;
    if (hasDotQuarter) w *= 0.7;
    if (endsWith16) w *= 0.9;     // (wonâ€™t end bar, but slightly less common)

    return w;
  });

  return weightedChoice(chunks, weights);
}

/* ----------------------------
   Melody rules
   - diatonic Eb major
   - no adjacent repeated notes
   - leaps <= perfect fifth (<= 7 semitones)
----------------------------- */

function candidateDeltas(){
  // Scale-step deltas; allow some variety up to ~a 5th
  // (5th in diatonic scale can be 4 scale steps)
  return [
    {d:-1,w:5.2}, {d:+1,w:5.2},
    {d:-2,w:3.0}, {d:+2,w:3.0},
    {d:-3,w:1.6}, {d:+3,w:1.6},
    {d:-4,w:0.9}, {d:+4,w:0.9}
  ];
}

function pickNextNote(prevIdx, prevMidi){
  const deltas = candidateDeltas();
  const delta = weightedChoice(deltas, deltas.map(x=>x.w)).d;

  let idx = (prevIdx + delta + SCALE_VEX.length) % SCALE_VEX.length;
  const pc = SCALE_VEX[idx];

  // choose octave close to previous, stay in range, enforce leap <= 7 semitones, and forbid same note
  const baseOct = prevMidi ? parseInt(Tone.Frequency(prevMidi, "midi").toNote().slice(-1), 10) : 5;
  const octChoices = [baseOct, baseOct+1, baseOct-1, baseOct+2, baseOct-2].map(o=>clamp(o,4,6));

  let best = null;
  for (const oct of octChoices){
    const vk = vexKey(pc, oct);
    const tn = vexToToneName(vk);
    const midi = Tone.Frequency(tn).toMidi();

    if (midi < MIDI_MIN || midi > MIDI_MAX) continue;

    if (prevMidi != null){
      const diff = Math.abs(midi - prevMidi);
      if (diff === 0) continue;                  // NO adjacent repeated notes
      if (diff > MAX_SEMITONE_LEAP) continue;    // <= fifth
    }

    best = { idx, vexKey: vk, tone: tn, midi };
    break;
  }

  // If that failed (rare), relax octave choice but still enforce "no repeat" and range
  if (!best){
    let bestDiff = Infinity;
    for (const oct of octChoices){
      const vk = vexKey(pc, oct);
      const tn = vexToToneName(vk);
      const midi = Tone.Frequency(tn).toMidi();
      if (midi < MIDI_MIN || midi > MIDI_MAX) continue;
      if (prevMidi != null && midi === prevMidi) continue;

      const diff = prevMidi == null ? 0 : Math.abs(midi - prevMidi);
      if (diff < bestDiff){
        bestDiff = diff;
        best = { idx, vexKey: vk, tone: tn, midi };
      }
    }
  }

  return best;
}

function generatePhrase(){
  const measures = [];
  let prevIdx = Math.floor(Math.random()*SCALE_VEX.length);
  let prevMidi = Tone.Frequency("Eb5").toMidi();

  for (let m=0; m<BARS; m++){
    let remaining = 4.0;
    const notes = [];

    // Build the rhythm as chunks (to enforce the 16th rules)
    while (remaining > 1e-9){
      const chunk = pickRhythmChunk(remaining);
      const chunkBeats = chunk.reduce((s,x)=>s+x.beats,0);

      // Safety: ensure we never leave exactly 0.25 remaining (since single 16th is forbidden)
      // If we would, try a different chunk by biasing away.
      if (Math.abs((remaining - chunkBeats) - 0.25) < 1e-9){
        // Prefer a different chunk if possible
        const alternatives = rhythmChunksThatFit(remaining).filter(ch => {
          const t = ch.reduce((s,x)=>s+x.beats,0);
          return Math.abs((remaining - t) - 0.25) > 1e-9;
        });
        if (alternatives.length){
          // pick an alternative (favor 0.5 or 1.0)
          const w = alternatives.map(ch => {
            const t = ch.reduce((s,x)=>s+x.beats,0);
            return t === 0.5 ? 2.2 : (t === 1.0 ? 1.6 : 1.0);
          });
          chunk.length = 0;
          chunk.push(...weightedChoice(alternatives, w));
        }
      }

      // For each atom in the chunk, pick a note (melody rules apply per note)
      for (const atom of chunk){
        const picked = pickNextNote(prevIdx, prevMidi);

        notes.push({
          vexKey: picked.vexKey,
          vfDur: atom.vf,
          beats: atom.beats,
          toneName: picked.tone
        });

        prevIdx = picked.idx;
        prevMidi = picked.midi;
      }

      remaining -= chunk.reduce((s,x)=>s+x.beats,0);
    }

    // End-of-bar check: ensure last note isn't a 16th (by design it shouldn't be)
    if (notes.length && notes[notes.length-1].vfDur === "16"){
      // Convert last two 16ths to an 8th as an emergency fix
      // (should almost never happen, but keeps formatting stable)
      notes.pop();
      notes.pop();
      const picked = pickNextNote(prevIdx, prevMidi);
      notes.push({ vexKey: picked.vexKey, vfDur:"8", beats:0.5, toneName: picked.tone });
      prevIdx = picked.idx;
      prevMidi = picked.midi;
    }

    measures.push(notes);
  }

  // Gentle cadence-ish end on Eb without breaking the fifth / no-repeat rules:
  const lastMeasure = measures[BARS-1];
  if (lastMeasure && lastMeasure.length >= 2){
    const prev = lastMeasure[lastMeasure.length-2];
    const prevMidi2 = Tone.Frequency(prev.toneName).toMidi();

    // choose Eb octave closest to prev and within leap <= fifth and not equal
    const candidates = [4,5,6].map(o => ({
      tone: `Eb${o}`,
      vexKey: `eb/${o}`,
      midi: Tone.Frequency(`Eb${o}`).toMidi()
    })).filter(c => c.midi >= MIDI_MIN && c.midi <= MIDI_MAX
                && c.midi !== prevMidi2
                && Math.abs(c.midi - prevMidi2) <= MAX_SEMITONE_LEAP);

    if (candidates.length){
      candidates.sort((a,b)=>Math.abs(a.midi-prevMidi2)-Math.abs(b.midi-prevMidi2));
      lastMeasure[lastMeasure.length-1].toneName = candidates[0].tone;
      lastMeasure[lastMeasure.length-1].vexKey = candidates[0].vexKey;
    }
  }

  return measures;
}

/* ----------------------------
   Render notation (VexFlow)
   - Even spacing: formatToStave per measure
   - No manual accidentals (key signature handles Eb major)
----------------------------- */
let currentPhrase = null;

function renderPhrase(phrase){
  const div = document.getElementById("notation");
  div.innerHTML = "";

  const VF = Vex.Flow;

  const width = Math.min(920, Math.max(640, div.clientWidth - 24));
  const height = 210;

  const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
  renderer.resize(width, height);
  const context = renderer.getContext();

  const staveY = 62;
  const margin = 18;
  const totalStaveWidth = width - margin*2;
  const measureWidth = totalStaveWidth / BARS;

  const staves = [];
  for (let i=0;i<BARS;i++){
    const x = margin + i*measureWidth;
    const stave = new VF.Stave(x, staveY, measureWidth);
    if (i === 0){
      stave.addClef("treble").addTimeSignature(TIME_SIG).addKeySignature("Eb");
    }
    stave.setContext(context).draw();
    staves.push(stave);
  }

  for (let i=0;i<BARS;i++){
    const vexNotes = phrase[i].map(n => new VF.StaveNote({
      clef: "treble",
      keys: [n.vexKey],
      duration: n.vfDur
    }));

    // Add dots for dotted durations (VexFlow supports "8d"/"qd", but this ensures correctness if needed)
    // If you ever switch to a different duration encoding, this keeps it safe.
    vexNotes.forEach((vn, idx) => {
      const dur = phrase[i][idx].vfDur;
      if (dur.endsWith("d")) vn.addDotToAll();
    });

    const beams = VF.Beam.generateBeams(vexNotes, { beam_rests: false });

    const voice = new VF.Voice({ num_beats: 4, beat_value: 4 }).setStrict(true);
    voice.addTickables(vexNotes);

    new VF.Formatter()
      .joinVoices([voice])
      .formatToStave([voice], staves[i], { padding: 8 });

    voice.draw(context, staves[i]);
    beams.forEach(b => b.setContext(context).draw());
  }
}

/* ----------------------------
   Audio playback (sampled flute via SoundFont)
   â€œMIDI-likeâ€ flute sound.
----------------------------- */
let sfAudioCtx = null;
let sfInstrument = null;
let sfPlaying = [];
let sfStopTimer = null;

async function ensureSoundFontFlute(){
  if (!sfAudioCtx){
    sfAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (sfAudioCtx.state === "suspended") await sfAudioCtx.resume();

  if (!sfInstrument){
    sfInstrument = await Soundfont.instrument(sfAudioCtx, "flute", {
      soundfont: "MusyngKite"
    });
  }
}

function stopPlayback(){
  try { sfPlaying.forEach(n => { try { n.stop(); } catch(e){} }); } catch(e){}
  sfPlaying = [];
  if (sfStopTimer) { clearTimeout(sfStopTimer); sfStopTimer = null; }

  document.getElementById("btnStop").disabled = true;
  document.getElementById("btnPlay").disabled = false;
}

function flattenToEvents(phrase){
  const events = [];
  let t = 0; // beats from start
  for (const measure of phrase){
    for (const n of measure){
      events.push({ timeBeats: t, note: n.toneName, beats: n.beats });
      t += n.beats;
    }
  }
  return events;
}

async function playPhrase(){
  await ensureSoundFontFlute();
  stopPlayback();

  const events = flattenToEvents(currentPhrase);
  const beatSeconds = 60 / TEMPO;
  const startAt = sfAudioCtx.currentTime + 0.05;

  for (const e of events){
    const when = startAt + e.timeBeats * beatSeconds;
    const durSec = e.beats * beatSeconds;

    const node = sfInstrument.play(e.note, when, { duration: durSec, gain: 0.9 });
    sfPlaying.push(node);
  }

  document.getElementById("btnStop").disabled = false;
  document.getElementById("btnPlay").disabled = true;

  const totalSeconds = (BARS * 4) * beatSeconds;
  sfStopTimer = setTimeout(() => stopPlayback(), (totalSeconds + 0.25) * 1000);
}

/* ----------------------------
   UI wiring
----------------------------- */
function generateAndRender(){
  stopPlayback();
  currentPhrase = generatePhrase();
  renderPhrase(currentPhrase);
}

document.getElementById("btnGen").addEventListener("click", generateAndRender);
document.getElementById("btnPlay").addEventListener("click", () => playPhrase());
document.getElementById("btnStop").addEventListener("click", stopPlayback);

generateAndRender();
</script>
</body>
</html>
