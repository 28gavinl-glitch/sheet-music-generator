<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Flute Spark â€” Stable Render</title>

  <script src="https://unpkg.com/vexflow@4.2.3/build/cjs/vexflow.js"></script>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    :root{
      --bg1:#fff5f8; --bg2:#ffe3ee; --card:#ffffffcc;
      --ink:#2a1b22; --muted:#6a4a58; --accent:#ff3b7a;
      --accent2:#ff7aa8; --shadow: 0 18px 50px rgba(30, 10, 20, .12);
      --radius: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
      color:var(--ink);
      background: radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent 60%), linear-gradient(180deg, var(--bg1), #fff);
    }
    .hearts{ position:fixed; inset:0; pointer-events:none; z-index:0; opacity:.5; }
    .heart{
      position:absolute; width:16px; height:16px; transform: rotate(45deg);
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      border-radius: 3px; animation: floatUp linear infinite;
    }
    .heart::before, .heart::after{ content:""; position:absolute; width:16px; height:16px; background: inherit; border-radius: 50%; }
    .heart::before{ left:-8px; top:0; } .heart::after{ left:0; top:-8px; }
    @keyframes floatUp{ from{ transform: translateY(110vh) rotate(45deg); } to{ transform: translateY(-10vh) rotate(45deg); } }

    .wrap{ position:relative; z-index:1; max-width: 900px; margin: 0 auto; padding: 40px 20px; }
    .card{ background: var(--card); backdrop-filter: blur(10px); border-radius: var(--radius); border: 1px solid #fff; box-shadow: var(--shadow); overflow:hidden; }
    .topbar{ display:flex; flex-wrap:wrap; align-items:center; justify-content:space-between; gap:12px; padding: 16px; border-bottom: 1px solid rgba(0,0,0,0.05); }
    .controls{ display:flex; gap:10px; }
    
    button{
      border:none; padding: 10px 18px; border-radius: 12px; cursor:pointer; font-weight:600;
      color:white; background: linear-gradient(180deg, var(--accent2), var(--accent));
      transition: transform 0.1s;
    }
    button:active{ transform: scale(0.96); }
    button.secondary{ color: var(--ink); background: #fff; border: 1px solid #ddd; }
    button:disabled{ opacity: 0.4; }

    #notation {
      width: 100%; min-height: 250px; overflow-x: auto; padding: 20px;
      background: rgba(255,255,255,0.4); border-radius: 14px;
      margin: 15px; width: calc(100% - 30px);
    }
    #notation svg { display: block; }
  </style>
</head>

<body>
  <div class="hearts" id="hearts"></div>
  <div class="wrap">
    <header>
      <h1 style="margin-bottom:5px;">Valentine Flute Spark ðŸ’˜</h1>
      <p style="color:var(--muted); margin-top:0;">Fast Eâ™­ Major Flute Lines (3 Measures)</p>
    </header>

    <div class="card">
      <div class="topbar">
        <div class="controls">
          <button id="btnGen">Generate âœ¨</button>
          <button id="btnPlay" class="secondary">Play â–¶ï¸Ž</button>
          <button id="btnStop" class="secondary" disabled>Stop â– </button>
        </div>
        <div style="font-size:13px; color:var(--muted); font-weight:600;">Eâ™­ Major â€¢ 156 BPM</div>
      </div>
      <div id="notation"></div>
    </div>
  </div>

<script>
/* Hearts Background */
(function(){
  const wrap = document.getElementById("hearts");
  for (let i=0; i<20; i++){
    const h = document.createElement("div"); h.className = "heart";
    h.style.left = Math.random()*100 + "vw";
    h.style.animationDuration = (6 + Math.random()*8) + "s";
    h.style.animationDelay = (-Math.random()*10) + "s";
    h.style.opacity = 0.2 + Math.random()*0.5;
    wrap.appendChild(h);
  }
})();

/* Logic Settings */
const TEMPO = 156;
const BARS = 3;
const SCALE = ["eb", "f", "g", "ab", "bb", "c", "d"];
const RHYTHMS = [
  { ticks: 1, vf: "16", tone: "16n", beats: 0.25 },
  { ticks: 2, vf: "8",  tone: "8n",  beats: 0.5 },
  { ticks: 4, vf: "q",  tone: "4n",  beats: 1.0 }
];

function generatePhrase() {
  const measures = [];
  let prevIdx = 0;
  for (let m=0; m<BARS; m++) {
    let rem = 16;
    const notes = [];
    while (rem > 0) {
      const r = RHYTHMS.filter(x => x.ticks <= rem)[Math.floor(Math.random() * RHYTHMS.filter(x => x.ticks <= rem).length)];
      const idx = (prevIdx + (Math.floor(Math.random()*3)-1) + 7) % 7;
      const oct = Math.random() > 0.5 ? 5 : 6;
      notes.push({ keys: [`${SCALE[idx]}/${oct}`], duration: r.vf, tone: r.tone, beats: r.beats, rawKey: `${SCALE[idx]}${oct}` });
      rem -= r.ticks;
      prevIdx = idx;
    }
    measures.push(notes);
  }
  return measures;
}

function tryRender(phrase) {
  const div = document.getElementById("notation");
  div.innerHTML = "";
  const VF = Vex.Flow;
  
  // Force a minimum width to prevent VexFlow from panicking
  const minWidth = 800; 
  const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
  renderer.resize(minWidth, 200);
  const context = renderer.getContext();
  const measureWidth = (minWidth - 50) / BARS;

  let x = 20;
  const staves = [];
  phrase.forEach((measure, i) => {
    const stave = new VF.Stave(x, 40, measureWidth);
    if (i === 0) stave.addClef("treble").addTimeSignature("4/4").addKeySignature("Eb");
    stave.setContext(context).draw();
    
    const vexNotes = measure.map(n => new VF.StaveNote({ clef: "treble", keys: n.keys, duration: n.duration }));
    const beams = VF.Beam.generateBeams(vexNotes);
    Vex.Flow.Formatter.FormatAndDraw(context, stave, vexNotes);
    beams.forEach(b => b.setContext(context).draw());
    
    x += measureWidth;
    staves.push(stave);
  });

  // Validation: Check if SVG has actual paths for notes (not just empty staves)
  const paths = div.querySelectorAll('path').length;
  return paths > 30; // Heuristic: A full 3-bar melody usually has >30 path elements
}

let currentPhrase = null;
async function generateAndVerify() {
  stopPlayback();
  let success = false;
  let attempts = 0;

  while (!success && attempts < 10) {
    currentPhrase = generatePhrase();
    success = tryRender(currentPhrase);
    attempts++;
  }
}

/* Audio */
let synth = null;
async function play() {
  await Tone.start();
  if (synth) synth.dispose();
  synth = new Tone.PolySynth(Tone.Synth).toDestination();
  
  const now = Tone.now();
  let time = 0;
  currentPhrase.flat().forEach(n => {
    synth.triggerAttackRelease(n.rawKey.replace('eb', 'Eb').replace('ab', 'Ab').replace('bb', 'Bb'), n.tone, now + time);
    time += n.beats * (60 / TEMPO);
  });

  document.getElementById("btnPlay").disabled = true;
  document.getElementById("btnStop").disabled = false;
  setTimeout(stopPlayback, time * 1000 + 500);
}

function stopPlayback() {
  Tone.Transport.stop();
  if (synth) synth.releaseAll();
  document.getElementById("btnPlay").disabled = false;
  document.getElementById("btnStop").disabled = true;
}

document.getElementById("btnGen").onclick = generateAndVerify;
document.getElementById("btnPlay").onclick = play;
document.getElementById("btnStop").onclick = stopPlayback;

// Initial Load
window.onload = generateAndVerify;
</script>
</body>
</html>
