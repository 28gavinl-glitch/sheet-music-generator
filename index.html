<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valentine Day Gift: Random Eb Major Line For Flute</title>

  <script src="https://unpkg.com/vexflow@4.2.3/build/cjs/vexflow.js"></script>
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <style>
    :root{
      --bg1:#fff5f8;
      --bg2:#ffe3ee;
      --card:#ffffffcc;
      --ink:#2a1b22;
      --muted:#6a4a58;
      --accent:#ff3b7a;
      --accent2:#ff7aa8;
      --shadow: 0 18px 50px rgba(30, 10, 20, .12);
      --radius: 22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:
        radial-gradient(1200px 800px at 20% 10%, var(--bg2), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, #fff, transparent 55%),
        radial-gradient(1000px 700px at 50% 95%, #ffd3e4, transparent 60%),
        linear-gradient(180deg, var(--bg1), #fff);
      overflow-x:hidden;
    }

    .hearts{ position:fixed; inset:0; pointer-events:none; z-index:0; opacity:.55; overflow:hidden; }
    .heart{
      position:absolute;
      width:16px; height:16px;
      transform: rotate(45deg);
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      border-radius: 3px;
      filter: drop-shadow(0 6px 8px rgba(255,59,122,.18));
      animation: floatUp linear infinite;
    }
    .heart::before, .heart::after{
      content:"";
      position:absolute;
      width:16px; height:16px;
      background: inherit;
      border-radius: 50%;
    }
    .heart::before{ left:-8px; top:0; }
    .heart::after{ left:0; top:-8px; }
    @keyframes floatUp{
      from{ transform: translateY(120vh) rotate(45deg); opacity:0; }
      15%{opacity:1;}
      to{ transform: translateY(-20vh) rotate(45deg); opacity:0; }
    }

    .wrap{
      position:relative; z-index:1;
      max-width: 980px;
      margin: 0 auto;
      padding: 44px 18px 54px;
    }

    header{ display:flex; align-items:flex-start; justify-content:space-between; gap:16px; margin-bottom:18px; }
    .title{ flex:1; }
    h1{ margin:0 0 8px 0; font-size: clamp(26px, 4vw, 40px); letter-spacing: -0.02em; line-height:1.05; }
    .subtitle{ margin:0; color:var(--muted); font-size: 15px; line-height:1.45; max-width: 62ch; }

    .card{
      background: var(--card);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.7);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .topbar{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(50,20,35,.08);
    }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }

    button{
      appearance:none;
      border:none;
      padding: 10px 14px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:650;
      font-size:14px;
      letter-spacing:.01em;
      color:white;
      background: linear-gradient(180deg, var(--accent2), var(--accent));
      box-shadow: 0 10px 22px rgba(255,59,122,.25);
      transition: transform .08s ease, box-shadow .2s ease, opacity .2s ease;
    }
    button:active{ transform: translateY(1px) scale(.99); }
    button.secondary{
      color: var(--ink);
      background: linear-gradient(180deg, #ffffff, #ffe9f2);
      border: 1px solid rgba(255,59,122,.25);
      box-shadow: 0 10px 22px rgba(30,10,20,.08);
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .pill{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; color: var(--muted); font-size: 13px; }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.75);
      border: 1px solid rgba(50,20,35,.08);
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(255,59,122,.15);
    }

    .stage{ padding: 16px; }

    #notation {
      width: 100%;
      min-height: 280px;
      overflow-x: auto;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 20px;
      border-radius: 18px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(50,20,35,.08);
      scrollbar-width: thin;
      scrollbar-color: var(--accent2) transparent;
    }
    #notation svg { display:block; margin: 0; } /* important: don't auto-center wide SVG */

    .footer{
      margin-top: 14px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      color: var(--muted);
      font-size: 13px;
      padding: 0 6px;
    }
    .small{ opacity:.9; line-height:1.4; }
  </style>
</head>

<body>
  <div class="hearts" id="hearts"></div>

  <div class="wrap">
    <header>
      <div class="title">
        <h1>For Chelsea Liu ðŸ’˜</h1>
        <p class="subtitle">
          This generates a one-line, fast-tempo flute passage in <b>Eâ™­ major</b>.
          Click <b>Generate</b> for a new line and <b>Play</b> to hear it.
        </p>
      </div>
    </header>

    <div class="card">
      <div class="topbar">
        <div class="controls">
          <button id="btnGen">Generate âœ¨</button>
          <button id="btnPlay" class="secondary">Play â–¶ï¸Ž</button>
          <button id="btnStop" class="secondary" disabled>Stop â– </button>
        </div>

        <div class="pill">
          <span class="badge"><span class="dot"></span>
            <span id="meta">Eâ™­ major â€¢ 4/4 â€¢ â™©=156 â€¢ 3 bars</span>
          </span>
        </div>
      </div>

      <div class="stage">
        <div id="notation"></div>
        <div class="footer">
          <div class="small">Tip: if audio doesnâ€™t start, click <b>Play</b> once more.</div>
          <div class="small">Uses VexFlow and Tone.js</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Floating hearts */
(function makeHearts(){
  const wrap = document.getElementById("hearts");
  const count = 26;
  for (let i=0;i<count;i++){
    const h = document.createElement("div");
    h.className = "heart";
    const left = Math.random()*100;
    const size = 10 + Math.random()*14;
    const dur  = 8 + Math.random()*10;
    const delay = -Math.random()*dur;
    h.style.left = left + "vw";
    h.style.width = size + "px";
    h.style.height = size + "px";
    h.style.animationDuration = dur + "s";
    h.style.animationDelay = delay + "s";
    h.style.opacity = (0.25 + Math.random()*0.6).toFixed(2);
    wrap.appendChild(h);
  }
})();

/* Settings */
const TEMPO = 156;
const BARS = 3;
const TIME_SIG = "4/4";
const SCALE_VEX = ["eb", "f", "g", "ab", "bb", "c", "d"];
const MIDI_MIN = 60;
const MIDI_MAX = 84;
const MAX_LEAP_SEMITONES = 7;

const TICKS_PER_BAR = 16; // 16 sixteenth-notes = 4/4

// âœ… ONLY durations that never confuse formatting: 16th, 8th, quarter
const RHYTHMS = [
  { ticks: 1, vf: "16", toneDur: "16n", beats: 0.25 },
  { ticks: 2, vf: "8",  toneDur: "8n",  beats: 0.50 },
  { ticks: 4, vf: "q",  toneDur: "4n",  beats: 1.00 }
];

function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for (let i=0;i<items.length;i++){
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length-1];
}

function weightedRhythmPickTicks(remainingTicks){
  const choices = RHYTHMS.filter(r => r.ticks <= remainingTicks);
  const weights = choices.map(r => {
    if (r.ticks === 1) return 5;
    if (r.ticks === 2) return 4;
    if (r.ticks === 4) return 2;
    return 1;
  });
  return weightedChoice(choices, weights);
}

function vexKey(pc, oct){ return `${pc}/${oct}`; }
function vexToToneName(vk){
  const [pc, oct] = vk.split("/");
  const letter = pc[0].toUpperCase();
  const accidental = pc.length > 1 ? "b" : "";
  return `${letter}${accidental}${oct}`;
}
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

function pickNextNote(prevIdx, prevMidi){
  const deltas = [
    {d:-1,w:5}, {d:+1,w:5},
    {d:-2,w:3}, {d:+2,w:3},
    {d:0,w:1.2},
    {d:-3,w:1}, {d:+3,w:1}
  ];
  const delta = weightedChoice(deltas, deltas.map(x=>x.w)).d;

  const idx = (prevIdx + delta + SCALE_VEX.length) % SCALE_VEX.length;
  const pc = SCALE_VEX[idx];

  const prevOctStr = prevMidi
    ? Tone.Frequency(prevMidi, "midi").toNote().replace(/[A-G][b#]?/, "")
    : "5";
  const baseOct = prevMidi ? parseInt(prevOctStr, 10) : 5;

  const octChoices = [baseOct, baseOct+1, baseOct-1, baseOct+2, baseOct-2].map(o=>clamp(o,4,6));

  for (const oct of octChoices){
    const vk = vexKey(pc, oct);
    const tn = vexToToneName(vk);
    const midi = Tone.Frequency(tn).toMidi();
    if (midi < MIDI_MIN || midi > MIDI_MAX) continue;
    if (prevMidi != null && Math.abs(midi - prevMidi) > MAX_LEAP_SEMITONES) continue;
    return { idx, vexKey: vk, tone: tn, midi };
  }

  // fallback: repeat-ish
  const pc2 = SCALE_VEX[prevIdx];
  const vk2 = vexKey(pc2, clamp(baseOct, 4, 6));
  const tn2 = vexToToneName(vk2);
  const midi2 = Tone.Frequency(tn2).toMidi();
  return { idx: prevIdx, vexKey: vk2, tone: tn2, midi: midi2 };
}

function generatePhrase(){
  const measures = [];
  let prevIdx = Math.floor(Math.random()*SCALE_VEX.length);
  let prevMidi = Tone.Frequency("Eb5").toMidi();

  for (let m=0; m<BARS; m++){
    let remaining = TICKS_PER_BAR;
    const notes = [];

    while (remaining > 0){
      const r = weightedRhythmPickTicks(remaining);
      const picked = pickNextNote(prevIdx, prevMidi);

      notes.push({
        vexKey: picked.vexKey,
        vfDur: r.vf,
        ticks: r.ticks,
        beats: r.beats,
        toneDur: r.toneDur,
        toneName: picked.tone
      });

      remaining -= r.ticks;
      prevIdx = picked.idx;
      prevMidi = picked.midi;
    }

    measures.push(notes);
  }
  return measures;
}

/* Rendering â€” brute reliable */
let currentPhrase = null;

function renderPhrase(phrase){
  const div = document.getElementById("notation");
  div.innerHTML = "";
  const VF = Vex.Flow;

  const maxNotesInBar = Math.max(...phrase.map(bar => bar.length));
  const perBarMin = 360;
  const perNote = 30;
  const perBar = Math.max(perBarMin, 160 + maxNotesInBar * perNote);

  const margin = 24;
  const width = Math.max(div.clientWidth - 40, margin*2 + perBar * BARS);
  const height = 290;

  const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
  renderer.resize(width, height);
  const context = renderer.getContext();

  const staveY = 90;
  const totalStaveWidth = width - margin * 2;
  const measureWidth = totalStaveWidth / BARS;

  const staves = [];
  for (let i=0; i<BARS; i++){
    const x = margin + (i * measureWidth);
    const stave = new VF.Stave(x, staveY, measureWidth);
    if (i === 0) stave.addClef("treble").addTimeSignature(TIME_SIG).addKeySignature("Eb");
    stave.setContext(context).draw();
    staves.push(stave);
  }

  for (let i=0; i<BARS; i++){
    const vexNotes = phrase[i].map(n => new VF.StaveNote({
      clef: "treble",
      keys: [n.vexKey],
      duration: n.vfDur
    }));

    // âœ… non-strict so VexFlow never aborts rendering
    const voice = new VF.Voice({ num_beats: 4, beat_value: 4 }).setStrict(false);
    voice.addTickables(vexNotes);

    const beams = VF.Beam.generateBeams(vexNotes, { beam_rests:false });

    new VF.Formatter()
      .joinVoices([voice])
      .formatToStave([voice], staves[i], { padding: 10 });

    voice.draw(context, staves[i]);
    beams.forEach(b => b.setContext(context).draw());
  }
}

function svgLooksDrawn(){
  const div = document.getElementById("notation");
  const svg = div.querySelector("svg");
  if (!svg) return false;
  // Noteheads/beams/etc -> lots of paths
  return svg.querySelectorAll("path").length > 60;
}

async function renderPhraseSafely(){
  const div = document.getElementById("notation");

  for (let i=0; i<12; i++){
    if (div.clientWidth > 300) break;
    await new Promise(r => requestAnimationFrame(r));
  }

  if (document.fonts && document.fonts.ready){
    try {
      await Promise.race([document.fonts.ready, new Promise(r => setTimeout(r, 200))]);
    } catch(e){}
  }

  for (let i=0; i<12; i++){
    try { renderPhrase(currentPhrase); } catch(e) {}
    await new Promise(r => requestAnimationFrame(r));
    if (svgLooksDrawn()) return;
  }

  // last resort: force width & try once
  div.style.minWidth = "1600px";
  await new Promise(r => requestAnimationFrame(r));
  renderPhrase(currentPhrase);
}

async function generateAndRender(){
  stopPlayback();
  currentPhrase = generatePhrase();
  await renderPhraseSafely();
}

/* Audio */
let synth = null, part = null;

function buildFluteishSynth(){
  const s = new Tone.Synth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.01, decay: 0.08, sustain: 0.6, release: 0.1 }
  });
  const air = new Tone.NoiseSynth({
    noise: { type: "pink" },
    envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.06 }
  });
  const filter = new Tone.Filter(2000, "lowpass");
  const reverb = new Tone.Reverb({ decay: 2.6, wet: 0.22 });
  const gain = new Tone.Gain(0.8);

  s.connect(filter);
  air.connect(filter);
  filter.connect(reverb);
  reverb.connect(gain);
  gain.toDestination();

  return {
    noteOn: (freq, time, dur) => {
      s.triggerAttackRelease(freq, dur, time, 0.85);
      air.triggerAttackRelease(dur, time, 0.25);
    },
    dispose: () => { s.dispose(); air.dispose(); filter.dispose(); reverb.dispose(); gain.dispose(); }
  };
}

async function playPhrase(){
  await Tone.start();
  Tone.Transport.stop(); Tone.Transport.cancel();
  Tone.Transport.bpm.value = TEMPO;

  if (part){ part.dispose(); part = null; }
  if (synth){ synth.dispose(); synth = null; }
  synth = buildFluteishSynth();

  const events = [];
  let t = 0;
  currentPhrase.flat().forEach(n => {
    events.push({ time: t, note: n.toneName, dur: n.toneDur, beats: n.beats });
    t += n.beats;
  });

  const beatSec = 60 / TEMPO;
  part = new Tone.Part((time, value) => {
    synth.noteOn(Tone.Frequency(value.note).toFrequency(), time, value.dur);
  }, events.map(e => [e.time * beatSec, e]));

  part.start(0);
  Tone.Transport.start("+0.08");

  document.getElementById("btnStop").disabled = false;
  document.getElementById("btnPlay").disabled = true;

  Tone.Transport.scheduleOnce(() => stopPlayback(), (BARS * 4) * beatSec + 0.12);
}

function stopPlayback(){
  try { Tone.Transport.stop(); Tone.Transport.cancel(); } catch(e){}
  if (part){ part.dispose(); part = null; }
  if (synth){ synth.dispose(); synth = null; }
  document.getElementById("btnStop").disabled = true;
  document.getElementById("btnPlay").disabled = false;
}

/* Events */
document.getElementById("btnGen").addEventListener("click", generateAndRender);
document.getElementById("btnPlay").addEventListener("click", playPhrase);
document.getElementById("btnStop").addEventListener("click", stopPlayback);

window.addEventListener("resize", () => currentPhrase && renderPhraseSafely());

// render after load + 2 frames (stable layout)
window.addEventListener("load", () => {
  requestAnimationFrame(() => requestAnimationFrame(() => generateAndRender()));
});
</script>
</body>
</html>
